package leetcode202212.hard;

import leetcode20200921to20201031.BasicTemplate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.PriorityQueue;

public class LC924MinimizeMalwareSpread extends BasicTemplate {
    public static void main(String[] args) {
        Logger log = LoggerFactory.getLogger("Main");
        var LC = new LC924MinimizeMalwareSpread();
    }

    /**
     * https://leetcode.com/problems/minimize-malware-spread/solutions/181120/java-union-find-solution/
     * 照找出刪除哪個 Malware 減少最多 散播
     * 就是要找出有哪些 點 只有一個來源 - 稱為 [唯一受感染]
     * 且哪一個來源 他能夠抵達最多的 ]唯一受感染[
     *
     * 有兩個做法
     * 每個感染源下去 BFS, 統計哪個 感染源有最多 [唯一受感染]
     *
     * 另一個是 Union find 沒想到 Union find 要做到這樣效果  想法要轉很多圈
     * 1. int[] p, 記載 parent, int[] size 記載這個 parent 有多少 子孫
     * 2. 先走過 graph, 把有連接的都 union
     * - p[pj] = pi;
     * - size[pi] += size[pj];, pi 成為 pj parent, 也繼承 pj 子孫數
     * - 這個 int[] size 就是未來找出 哪感染源有最多 [唯一受感染]
     * 3. 所有 malware 都拿去找 parent, 記載每個 parent 被幾個 mal 共享
     * - int[] malParents = new int[m]; 記載每個 mal 的 parent
     * - Map<Integer, Integer> parentMalCount 每個 mal parent 有踩到幾個 mal
     * 4. 所以走過 malParents[i], parentMalCount.get(malParents[i]) == 1
     * - 代表 這個 parent 只有被一個 mal 踩到, 接觸到的子孫 都是 [唯一受感染] !!
     * - 就可以更新  maxAffectNum 以及 res = initial[i];
     * */
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        int[] p = new int[n];
        int[] size = new int[n];
        for (int i = 0; i < n; i++) p[i] = i;
        Arrays.fill(size, 1);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1 && i != j) {
                    int pi = f(p, i);
                    int pj = f(p, j);
                    if (pi != pj) {
                        p[pj] = pi;
                        size[pi] += size[pj];
                    }
                }
            }
        }

        int m = initial.length;
        int[] malParents = new int[m];
        Map<Integer, Integer> parentMalCount = new HashMap<>();

        for (int i = 0; i < m; i++) {
            int malParent = f(p, initial[i]);
            parentMalCount.put(malParent, parentMalCount.getOrDefault(malParent, 0) + 1);
            malParents[i] = malParent;
        }

        int res = initial[0], maxAffectNum = 0;
        for (int i = 0; i < m; i++) {
            int affectNum = 0;
            if (parentMalCount.get(malParents[i]) == 1) {
                affectNum = size[malParents[i]];
            }
            if (affectNum > maxAffectNum || (affectNum == maxAffectNum && initial[i] < res)) {
                res = initial[i];
                maxAffectNum = affectNum;
            }
        }
        return res;
    }

    int f(int[] p, int i) {
        while (i != p[i]) {
            p[i] = p[p[i]];
            i = p[i];
        }
        return p[i];
    }
}
