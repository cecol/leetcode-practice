package leetcode202212.hard;

import leetcode20200921to20201031.BasicTemplate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.Inet4Address;
import java.util.*;

public class LC928MinimizeMalwareSpreadII extends BasicTemplate {
    public static void main(String[] args) {
        Logger log = LoggerFactory.getLogger("Main");
        var LC = new LC928MinimizeMalwareSpreadII();
    }

    /**
     * https://leetcode.com/problems/minimize-malware-spread-ii/solutions/184068/minimize-malware-spread-ii/
     * 這題思路要轉下
     * 要先看清楚題目是說, 拿掉哪個 initial[i] 會感染最少
     * https://github.com/wisdompeak/LeetCode/tree/master/BFS/928.Minimize-Malware-Spread-II
     * 得反過來思考, 哪些節點只有一個感染源? 他的 edge == 1
     * 所以要建立一張
     * ArrayList<Integer>[] infectedBy
     *
     * 先從每個感染源 initial[i] dfs 下去看他可以感染到誰: Set<Integer> seen
     * 回來之後 被感染的來記載他的感然源是誰!!
     * - for (int v : seen) infectedBy[v].add(m);
     *
     * 然後走過 if (infectedBy[i].size() == 1) contribution[infectedBy[i].get(0)]++; 來累計哪些感染源
     * 如果 該感染源 被拿掉, 有多少可以被拯救！！
     *
     * 最後就就是 走過 contribution 看看誰拯救最多!!
     *
     * 整題要用 拯救的總數概念來思考就會比較直觀
     * 但這個思考要轉換一下
     * */
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        Set<Integer> initialM = new HashSet<>();
        for (int m : initial) initialM.add(m);

        ArrayList<Integer>[] infectedBy = new ArrayList[n];
        for (int i = 0; i < n; i++) infectedBy[i] = new ArrayList<>();

        for (int m : initial) {
            Set<Integer> seen = new HashSet<>();
            dfs(graph, initialM, m, seen);
            for (int v : seen) infectedBy[v].add(m);
        }

        int[] contribution = new int[n];
        for (int i = 0; i < n; i++) {
            if (infectedBy[i].size() == 1) contribution[infectedBy[i].get(0)]++;
        }

        Arrays.sort(initial);
        int res = initial[0], mx = -1;
        for (int m : initial) {
            int score = contribution[m];
            if(score > mx || (score == mx && m < res)) {
                res = m;
                mx = score;
            }
        }
        return res;
    }


    void dfs(int[][] graph, Set<Integer> initialM, int m, Set<Integer> seen) {
        for (int i = 0; i < graph.length; i++) {
            if (graph[m][i] == 1 && !initialM.contains(i) && !seen.contains(i)) {
                seen.add(i);
                dfs(graph, initialM, i, seen);
            }
        }
    }
}
